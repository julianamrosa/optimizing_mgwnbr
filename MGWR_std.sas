%macro MGWR(DATA=,YVAR=,XVAR=,WEIGHT=,LAT=,LONG=,OUTPUT=_band_,GLOBALMIN=YES,METHOD=,MODEL=GAUSSIAN,MGWR=YES,BANDWIDTH=CV,OFFSET=,DISTANCEKM=NO,INT=50,H=);
proc iml;
use &DATA;
read all var {&YVAR} into y;
read all var {&XVAR} into x[colname=varname];
n=nrow(y);
wt=j(n,1,1);
%IF &WEIGHT NE %THEN %DO;
read all var {&WEIGHT} into wt;
%END;
offset=j(n,1,0);
%IF &OFFSET NE %THEN %DO;
read all var {&OFFSET} into offset;
%END;
meanx=mean(x);
stdx=std(x);
xnstd=x;
x=(x - meanx)/stdx;
%IF %UPCASE(&MODEL)=GAUSSIAN %THEN %DO;
meany=mean(y);
stdy=std(y);
ynstd=y;
y=(y-meany)/stdy;
%END;
x=j(n,1,1)||x;
nvarg=ncol(x);
yhat=j(n,1,0);
bi=j(nvarg*n,4,0);
alphai=j(n,3,0);
S=j(n,1,0);
mRj=j(n,n*nvarg,0);
Sm=j(n,n,0);
Sm3=j(n,nvarg,0);
Rj=j(n,n,0);
Cm=j(n,n*nvarg,0);
stdbm=j(n,nvarg,0);
mAi=j(n,nvarg,0);
ENP=j(1,nvarg+2,0);

/**** global estimates ****/

%IF %UPCASE(&MODEL)=POISSON or %UPCASE(&MODEL)=NEGBIN %THEN %DO;
uj=(y+y[:])/2;
nj=log(uj);
parg=sum((y-uj)##2/uj)/(n-nvarg);
ddpar=1;
cont=1;
do while (abs(ddpar)>0.000001 & cont<100);
dpar=1;
parold=parg;
cont1=1;cont3=1;
%IF %UPCASE(&MODEL)=POISSON %THEN %DO;
alphag=1E-6;parg=1/alphag;
%END;
%IF %UPCASE(&MODEL)=NEGBIN %THEN %DO;
if cont>1 then parg=1/(sum((y-uj)##2/uj)/(n-nvarg));
do while (abs(dpar)>0.000001 & cont1<200);
	parg=choose(parg<1E-10,1E-10,parg);
	g=sum(digamma(parg+y)-digamma(parg)+log(parg)+1-log(parg+uj)-(parg+y)/(parg+uj));
	hess=sum(trigamma(parg+y)-trigamma(parg)+1/parg-2/(parg+uj)+(y+parg)/(parg+uj)##2);
	hess=choose(hess=0,1E-23,hess);
	par0=parg;
	parg=par0-inv(hess)*g;
	if cont1>50 & parg>1E5 then do;
		dpar= 0.0001;
		cont3=cont3+1;
		if cont3=1 then parg=2 ;	
		else if cont3=2 then parg=1E5;
		else if cont3=3 then parg=0.0001; 
	end;
	else dpar=parg-par0;
	cont1=cont1+1;
	if parg>1E6 then do;parg=1E6;dpar=0;end;
end;
alphag=1/parg;
%END;
devg=0; ddev=1; cont2=0;
do while (abs(ddev)>0.000001 & cont2<100);
	uj=choose(uj>1E100,1E100,uj);
	Ai=(uj/(1+alphag*uj))+(y-uj)#(alphag*uj/(1+2*alphag*uj+alphag**2*uj#uj));;
	Ai=choose(Ai<=0,1E-5,Ai);	
	zj=nj+(y-uj)/(Ai#(1+alphag*uj))-offset;
	if det(x`*(Ai#x))=0 then bg=j(nvarg,1,0);
	else bg=inv(x`*(Ai#x))*x`*(Ai#zj); 
	nj=x*bg+offset;
	nj=choose(nj>1E2,1E2,nj);
	uj=exp(nj);
	olddev=devg;
	uj=choose(uj<1E-150,1E-150,uj);
	tt=y/uj;
	tt=choose(tt=0,1E-10,tt);
	%IF %UPCASE(&MODEL)=POISSON %THEN %DO;
	devg=2*sum(y#log(tt)-(y-uj));
	%END;
	%IF %UPCASE(&MODEL)=NEGBIN %THEN %DO;
	devg=2*sum(y#log(tt)-(y+1/alphag)#log((1+alphag*y)/(1+alphag*uj)));
	sealphag=sqrt(1/abs(hess))/(parg**2);
	%END;
	if cont2>100 then ddev= 0.0000001;
	else ddev=devg-olddev;
	cont2=cont2+1;
end;
ujg=uj;
yhat=uj;
cont=cont+1;
ddpar=parg-parold;
end;
varg=vecdiag(inv((x#wt#Ai)`*x));
%END;

%IF %UPCASE(&MODEL)=LOGISTIC %THEN %DO;
uj=(y+y[:])/2;
nj=log(uj/(1-uj));
devg=0; ddev=1; cont=0;
do while (abs(ddev)>0.000001 & cont<100);
	uj=choose(uj>1E100,1E100,uj);
	Ai=uj#(1-uj);
	Ai=choose(Ai<=0,1E-5,Ai);	
	zj=nj+(y-uj)/Ai;
	if det(x`*(wt#Ai#x))=0 then bg=j(nvarg,1,0);
	else bg=inv(x`*(wt#Ai#x))*x`*(wt#Ai#zj); 
	nj=x*bg;
	nj=choose(nj>1E2,1E2,nj);
	uj=exp(nj)/(1+exp(nj));
	olddev=devg;
	uj=choose(uj<1E-150,1E-150,uj);
	tt=y/uj;
	tt=choose(tt=0,1E-10,tt);
	uj=choose(uj=1,0.99999,uj);
	tt2=(1-y)/(1-uj);
	tt2=choose(tt2=0,1E-10,tt2);
	devg=2#sum((y#log(tt))+(1-y)#log(tt2));
	ddev=devg-olddev;
	cont=cont+1;
end;
ujg=uj;
yhat=uj;
varg=vecdiag(inv((x#wt#Ai)`*x));
%END;
/*****************************************/

read all var{&LONG &LAT} into COORD;                                                                                                                      
close &DATA;
_dist_ = distance(COORD, "L2");
seq=1:n;

start cv(h,y,x,fi) global(n, wt, ujg, yhat, coord, _dist_, seq, offset, alphag, alphai, S, parg,yhat_beta);
nvar=ncol(x);
%IF %UPCASE(&METHOD)=FIXED_G or %UPCASE(&METHOD)=FIXED_BSQ or %UPCASE(&METHOD)=ADAPTIVE_BSQ %THEN %DO;
	do i=1 to n;
%END;
	do j=1 to n;
		seqi=j(n,1,i);
	    dist=seqi||seq`||_dist_[,i];
	%IF %UPCASE(&DISTANCEKM)=YES %THEN %DO;
		dist[,3]=dist[,3]*111;
	%END;
	end;
u=nrow(dist);
w=j(u,1,0);
	do jj=1 to u;
		w[jj]=exp(-0.5*(dist[jj,3]/h)**2);
		%if %UPCASE(&BANDWIDTH)=CV %THEN %DO;w[i]=0;%END;
	end;
%IF %UPCASE(&METHOD)=FIXED_BSQ %THEN %DO;
		position=loc(dist[,3]>h);
		w[position]=0;
%END;
%IF %UPCASE(&METHOD)=ADAPTIVE_BSQ %THEN %DO;
	call sort(dist,{3});
	dist=dist||(1:nrow(dist))`;
	w=j(n,2,0);	
	hn=dist[h,3];
	do jj=1 to n;
 		if dist[jj,4]<=h then
		w[jj,1]=(1-(dist[jj,3]/hn)**2)**2;
		else w[jj,1]=0;
		w[jj,2]=dist[jj,2];
	end;
	%if %UPCASE(&BANDWIDTH)=CV %THEN %DO;w[loc(w[,2]=i)]=0;%END;
	call sort(w,{2});
	w=w[,1];
%END;
%IF %UPCASE(&MODEL)=GAUSSIAN %THEN %DO;
	if det(x`*(w#x#wt))=0 then b=j(nvar,1,0);
	else
	b=inv(x`*(w#x#wt))*x`*(w#y#wt);
		yhat[i]=x[i,]*b;
		if det(x`*(w#x#wt))=0 then S[i]=0;
		else S[i]= (x[i,]*inv(x`*(w#x#wt))*(x#w#wt)`)[i];
	end;
	CV=((y-yhat)#wt)`*(y-yhat);
	npar=sum(S);
	AICc=2*n*log(CV/n)+n*log(2*3.14159)+n*(n+npar)/(n-2-npar);
	%if %UPCASE(&BANDWIDTH)=AIC %THEN %DO;CV=AICC;%END;
%END;
%IF %UPCASE(&MODEL)=POISSON or %UPCASE(&MODEL)=NEGBIN %THEN %DO;
uj=yhat;
par=parg;
nj=log(uj);
ddpar=1;
cont=1;cont3=0;
do while (abs(ddpar)>0.000001 & cont<100);
dpar=1;
parold=par;
cont1=1;
%IF %UPCASE(&MODEL)=POISSON %THEN %DO;
alpha=1E-6;par=1/alpha;
%END;
%IF %UPCASE(&MODEL)=NEGBIN %THEN %DO;
if par<=1E-5 then do;if i>1 then par=1/alphai[i-1,2];end;
do while (abs(dpar)>0.000001 & cont1<200);
	par=choose(par<1E-10,1E-10,par);
	g=sum(w#wt#(digamma(par+y)-digamma(par)+log(par)+1-log(par+uj)-(par+y)/(par+uj)));
	hess=sum(w#wt#(trigamma(par+y)-trigamma(par)+1/par-2/(par+uj)+(y+par)/(par+uj)##2));
	hess=choose(hess=0,1E-23,hess);
	par0=par;
	par=par0-inv(hess)*g;
	if cont1>50 & par>1E5 then do;
		dpar= 0.0001;
		cont3=cont3+1;
		if cont3=1 then par=2 ;	
		else if cont3=2 then par=1E5;
		else if cont3=3 then par=0.0001; 
	end;
	else dpar=par-par0;
	cont1=cont1+1;
	if par>1E6 then do;par=1E6;dpar=0;end;
	if par<=1E-5 then do;par=1E-3;dpar=0;end;
end;
alpha=1/par;
%END;
dev=0; ddev=1; cont2=1;
do while (abs(ddev)>0.000001 & cont2<100);
	uj=choose(uj>1E100,1E100,uj);
	Ai=(uj/(1+alpha*uj))+(y-uj)#(alpha*uj/(1+2*alpha*uj+alpha**2*uj#uj));
	Ai=choose(Ai<=0,1E-5,Ai);	
    zj=nj+(y-uj)/(Ai#(1+alpha*uj))-yhat_beta+fi;
	if det(x`*(w#Ai#x#wt))=0 then b=j(nvar,1,0);
	else b=inv(x`*(w#Ai#x#wt))*x`*(w#Ai#wt#zj); 
	nj=x*b+yhat_beta-fi;
	nj=choose(nj>1E2,1E2,nj);
	uj=exp(nj);
	olddev=dev;
	uj=choose(uj<1E-150,1E-150,uj);
	tt=y/uj;
	tt=choose(tt=0,1E-10,tt);
	%IF %UPCASE(&MODEL)=POISSON %THEN %DO;
	dev=2*sum(y#log(tt)-(y-uj));
	%END;
	%IF %UPCASE(&MODEL)=NEGBIN %THEN %DO;
	dev=2*sum(y#log(tt)-(y+1/alpha)#log((1+alpha*y)/(1+alpha*uj)));
	%END;
	if cont2>100 then ddev=0.0000001;
	else ddev=dev-olddev;
	cont2=cont2+1;
end;
cont=cont+1;
ddpar=par-parold;
end;
		yhat[i]=uj[i];
		alphai[i,2]= alpha;
		if det(x`*(w#Ai#x#wt))=0 then S[i]=0;
		else S[i]= (x[i,]*inv(x`*(w#Ai#x#wt))*(x#w#Ai#wt)`)[i];
	end;
	CV=((y-yhat)#wt)`*(y-yhat);
	%IF %UPCASE(&MODEL)=POISSON %THEN %DO;
	ll=sum(-yhat+y#log(yhat)-lgamma(y+1));
	npar=sum(S);
	%END;
	%IF %UPCASE(&MODEL)=NEGBIN %THEN %DO;
	ll=sum(y#log(alphai[,2]#yhat)-(y+1/alphai[,2])#log(1+alphai[,2]#yhat)+lgamma(y+1/alphai[,2])-lgamma(1/alphai[,2])-lgamma(y+1));
	npar=sum(S)+sum(S)/nvar;
	%END;
	AIC= 2*npar-2*ll;
	AICC= AIC +(2*npar*(npar+1))/(n-npar-1);
	%if %UPCASE(&BANDWIDTH)=AIC %THEN %DO;CV=AICC;%END;
%END;
%IF %UPCASE(&MODEL)=LOGISTIC %THEN %DO;
uj=yhat;
nj=log(uj/(1-uj));
dev=0; ddev=1; cont=0;
	do while (abs(ddev)>0.000001 & cont<100);
		cont=cont+1;
		uj=choose(uj>1E100,1E100,uj);
		Ai=uj#(1-uj);
		Ai=choose(Ai<=0,1E-5,Ai);	
		zj=nj+(y-uj)/Ai-yhat_beta+fi;
		if det(x`*(w#Ai#x#wt))=0 then b=j(nvar,1,0);
		else b=inv(x`*(w#Ai#x#wt))*x`*(w#Ai#wt#zj); 
		nj=x*b+yhat_beta-fi;
		nj=choose(nj>1E2,1E2,nj);
		uj=exp(nj)/(1+exp(nj));
		olddev=dev;
		uj=choose(uj<1E-150,1E-150,uj);
		tt=y/uj;
		tt=choose(tt=0,1E-10,tt);
		uj=choose(uj=1,0.99999,uj);
		tt2=(1-y)/(1-uj);
		tt2=choose(tt2=0,1E-10,tt2);
		dev=2#sum((y#log(tt))+(1-y)#log(tt2));
		if cont>100 then ddev= 0.0000001;
		else ddev=dev-olddev;
	end;
		yhat[i]=uj[i];
		if det(x`*(w#Ai#x#wt))=0 then S[i]=0;
		else S[i]= (x[i,]*inv(x`*(w#Ai#x#wt))*(x#w#wt#Ai)`)[i];
	end;
	uj=choose(uj=0,1E-10,uj);
	uj=choose(uj=1,0.99999,uj);
	CV=((y-yhat)#wt)`*(y-yhat);
	ll=sum(y#log(uj)-(1-y)#log(1-uj));
	npar=sum(S);
	AIC= 2*npar-2*ll;
	AICC= AIC +(2*npar*(npar+1))/(n-npar-1);
	%if %UPCASE(&BANDWIDTH)=AIC %THEN %DO;CV=AICC;%END;
%END;
free dist w;
res=cv||npar;
return (res);
finish cv;

start GSS(depy,indepx,fix) global(_dist_,n);
/**** DEFINING GOLDEN SECTION SEARCH PARAMETERS *****/
%IF %UPCASE(&METHOD)=FIXED_G or %UPCASE(&METHOD)=FIXED_BSQ %THEN %DO;
ax=0;
bx=int(max(_dist_)+1);
%IF %UPCASE(&DISTANCEKM)=YES %THEN %DO;bx=bx*111;%END;
%END;
%IF %UPCASE(&METHOD)=ADAPTIVE_BSQ %THEN %DO;
ax=5;
bx=n;
%END;
r=0.61803399;
tol=0.1;
%IF %UPCASE(&GLOBALMIN)=NO %THEN %DO;
lower=ax;
upper=bx;
xmin=j(1,2,0);
do GMY=1 to 1;
ax1=lower[GMY];
bx1=upper[GMY];
%END;
%ELSE %DO;
lower=ax||(1-r)*bx||r*bx;
upper=(1-r)*bx||r*bx||bx;
xmin=j(3,2,0);
do GMY=1 to 3;
ax1=lower[GMY];
bx1=upper[GMY];
%END;
h0=ax1;
h3=bx1;
h1=bx1-r*(bx1-ax1);
h2=ax1+r*(bx1-ax1);
*print h0 h1 h2 h3;
/***************************************/

res1=cv(h1,depy,indepx,fix);CV1=res1[1];
res2=cv(h2,depy,indepx,fix);CV2=res2[1];

int=1;
do while(abs(h3-h0) > tol*(abs(h1)+abs(h2)) & int<200);
	if CV2<CV1 then do;
		h0=h1;
		h1=h3-r*(h3-h0);
		h2=h0+r*(h3-h0);
		CV1=CV2;
		res2=cv(h2,depy,indepx,fix);CV2=res2[1];
	end;
	else do;
		h3=h2;
		h1=h3-r*(h3-h0);
		h2=h0+r*(h3-h0);
		CV2=CV1;
		res1=cv(h1,depy,indepx,fix);CV1=res1[1];
	end;
int=int+1;
end;
if CV1<CV2 then do;
	golden=CV1;
	xmin[GMY,1]=golden;
	xmin[GMY,2]=h1;
	npar=res1[1];
%IF %UPCASE(&METHOD)=ADAPTIVE_BSQ %THEN %DO;
	xmin[GMY,2]=floor(h1);
	xming=xmin[GMY,2];
%END;
end;
else do;
	golden=CV2;
	xmin[GMY,1]=golden;
	xmin[GMY,2]=h2;
	npar=res2[1];
%IF %UPCASE(&METHOD)=ADAPTIVE_BSQ %THEN %DO;
	xmin[GMY,2]=floor(h2);
	xming=xmin[GMY,2];
%END;
end;
	xming=xmin[GMY,2];
	/*print golden (xmin[GMY,2])[label='xmin'] %if %UPCASE(&BANDWIDTH)=AIC %THEN %DO;npar%END;;*/
end;
%IF %UPCASE(&GLOBALMIN)=YES %THEN %DO;
*print xmin[colname={'golden' 'bandwidth'}];
xming=xmin[loc(xmin[,1]=min(xmin[,1])),2];
/*print 'Global Minimum', xming[label='(Da Silva and Mendes (2018)'];*/
%END;
bandwidth=xming;
return (bandwidth);
finish;

start gwr(h,y,x,fi) global(_dist_,n,nvarg,seq,wt,ujg,parg,yhat,offset,Sm,Sm3,Rj,mRj,alphai,yhat_beta,Ai);
nvar=ncol(x);
bim=j(nvar*n,1,0);
yhatm=j(n,1,0);
do i=1 to n;
	do j=1 to n;                                                                                                                          
	seqi=j(n,1,i);
	    dist=seqi||seq`||_dist_[,i];
	%IF %UPCASE(&DISTANCEKM)=YES %THEN %DO;
		dist[,3]=dist[,3]*111;
	%END;
	end;
	u=nrow(dist);
	w=j(u,1,0);
	do jj=1 to u;
%IF %UPCASE(&METHOD)=FIXED_G %THEN %DO;
		w[jj]=exp(-(dist[jj,3]/h)**2);
%END;
%ELSE %IF %UPCASE(&METHOD)=FIXED_BSQ %THEN %DO;
		w[jj]=(1-(dist[jj,3]/h)**2)**2;
%END;
	end;
	%IF %UPCASE(&METHOD)=ADAPTIVE_BSQ %THEN %DO;
	call sort(dist,{3});
	dist=dist||(1:nrow(dist))`;
	w=j(n,2,0);	 
	hn=dist[h,3];
	do jj=1 to n;
 		if dist[jj,4]<=h then
		w[jj,1]=(1-(dist[jj,3]/hn)**2)**2;
		else w[jj,1]=0;
		w[jj,2]=dist[jj,2];
	end;
	call sort(w,{2});
	w=w[,1];
	%END;
/****** MODEL SELECTION *************/
%IF %UPCASE(&MODEL)=GAUSSIAN %THEN %DO;
	if det(x`*(w#x#wt))=0 then b=j(nvar,1,0);
	else b=inv(x`*(w#x#wt))*x`*(w#y#wt);
	uj=x*b;
	if nvar=nvarg then do;
		if det(x`*(w#x#wt))=0 then do;Sm[i,]=j(1,n,0);mRj[i,]=j(1,n*nvar,0);end;
		else do;
			ej=I(nvar);
			Sm[i,]= (x[i,]*inv(x`*(w#x#wt))*(x#w#wt)`);
			Sm3[i,]= vecdiag((inv(x`*(w#x#wt))*(x#w#wt)`)*(inv(x`*(w#x#wt))*(x#w#wt)`)`)`;
			do jj=1 to nvar;
			m1=(jj-1)*n+1;
			m2=m1+(n-1);
			mRj[i,m1:m2]= (x[i,jj]*ej[jj,]*inv(x`*(w#x#wt))*(x#w#wt)`);
			end;
		end;
	end;
	else do;
		if det(x`*(w#x#wt))=0 then Rj[i,]=j(1,n,0);
		else Rj[i,]= (x[i,]*inv(x`*(w#x#wt))*(x#w#wt)`);
	end;
%END;
%IF %UPCASE(&MODEL)=POISSON or %UPCASE(&MODEL)=NEGBIN %THEN %DO;
uj=yhat;
par=parg;
nj=log(uj);
ddpar=1;
cont=1;
do while (abs(ddpar)>0.000001 & cont<100);
dpar=1;
parold=par;
cont1=1;cont3=1;
%IF %UPCASE(&MODEL)=POISSON %THEN %DO;
alpha=1E-6;par=1/alpha;
%END;
%IF %UPCASE(&MODEL)=NEGBIN %THEN %DO;
if par<=1E-5 then do;if i>1 then par=1/alphai[i-1,2];end;
do while (abs(dpar)>0.000001 & cont1<200);
	par=choose(par<1E-10,1E-10,par);
	g=sum(w#wt#(digamma(par+y)-digamma(par)+log(par)+1-log(par+uj)-(par+y)/(par+uj)));
	hess=sum(w#wt#(trigamma(par+y)-trigamma(par)+1/par-2/(par+uj)+(y+par)/(par+uj)##2));
	hess=choose(hess=0,1E-23,hess);
	par0=par;
	par=par0-inv(hess)*g;
	if cont1>50 & par>1E5 then do;
		dpar= 0.0001;
		cont3=cont3+1;
		if cont3=1 then par=2 ;	
		else if cont3=2 then par=1E5;
		else if cont3=3 then par=0.0001; 
	end;
	else dpar=par-par0;
	cont1=cont1+1;
	if par>1E6 then do;par=1E6;dpar=0;end;
	if par<=1E-5 then do;par=1E-3;dpar=0;end;
end;
alpha=1/par;
%END;
dev=0; ddev=1; cont2=0;
do while (abs(ddev)>0.000001 & cont2<100);
		uj=choose(uj>1E100,1E100,uj);
		Ai=(uj/(1+alpha*uj))+(y-uj)#(alpha*uj/(1+2*alpha*uj+alpha**2*uj#uj));
		Ai=choose(Ai<=0,1E-5,Ai);	
		zj=nj+(y-uj)/(Ai#(1+alpha*uj))-yhat_beta+fi;
		if det(x`*(w#Ai#x#wt))=0 then b=j(nvar,1,0);
		else b=inv(x`*(w#Ai#x#wt))*x`*(w#Ai#wt#zj); 
		nj=x*b+yhat_beta-fi;
		nj=choose(nj>1E2,1E2,nj);
		uj=exp(nj);
		olddev=dev;
		uj=choose(uj<1E-150,1E-150,uj);
		tt=y/uj;
		tt=choose(tt=0,1E-10,tt);
		%IF %UPCASE(&MODEL)=POISSON %THEN %DO;
		dev=2*sum(y#log(tt)-(y-uj));
		%END;
		%IF %UPCASE(&MODEL)=NEGBIN %THEN %DO;
		dev=2*sum(y#log(tt)-(y+1/alpha)#log((1+alpha*y)/(1+alpha*uj)));
		%END;
		cont2=cont2+1;
	end;
cont=cont+1;
ddpar=par-parold;
end;
	if nvar=nvarg then do;
		if det(x`*(w#Ai#x#wt))=0 then do;Sm[i,]=j(1,n,0);mRj[i,]=j(1,n*nvar,0);end;
		else do;
			ej=I(nvar);
			Sm[i,]= (x[i,]*inv(x`*(w#Ai#x#wt))*(x#w#wt#Ai)`);
			Sm3[i,]= vecdiag((inv(x`*(w#Ai#x#wt))*(x#w#wt#Ai)`)*diag(1/Ai)*(inv(x`*(w#Ai#x#wt))*(x#w#wt#Ai)`)`)`;
			do jj=1 to nvar;
			m1=(jj-1)*n+1;
			m2=m1+(n-1);
			mRj[i,m1:m2]= (x[i,jj]*ej[jj,]*inv(x`*(w#Ai#x#wt))*(x#w#wt#Ai)`);
			end;
		end;
	end;
	else do;
		if det(x`*(w#Ai#x#wt))=0 then Rj[i,]=j(1,n,0);
		else Rj[i,]= (x[i,]*inv(x`*(w#Ai#x#wt))*(x#w#wt#Ai)`);
	end;
	%IF %UPCASE(&MODEL)=NEGBIN %THEN %DO;
	hess=sum(w#wt#(trigamma(par+y)-trigamma(par)+1/par-2/(par+exp(yhat_beta))+(y+par)/(par+exp(yhat_beta))##2));
	%IF %UPCASE(&MGWR) ne YES %THEN %DO;
	hess=sum(w#wt#(trigamma(par+y)-trigamma(par)+1/par-2/(par+uj)+(y+par)/(par+uj)##2));
	hess=choose(hess=0,1E-23,hess);
	%END;
	sealpha=sqrt(1/abs(hess))/(par**2); 
	alphai[i,1]=i;
	alphai[i,2]=alpha;
	alphai[i,3]=sealpha;
	%END;
%END;
%IF %UPCASE(&MODEL)=LOGISTIC %THEN %DO;
uj=yhat;
nj=log(uj/(1-uj));
dev=0; ddev=1; cont=1;
do while (abs(ddev)>0.000001 & cont<100);
		cont=cont+1;
		uj=choose(uj>1E100,1E100,uj);
		Ai=uj#(1-uj);
		Ai=choose(Ai<=0,1E-5,Ai);	
		zj=nj+(y-uj)/Ai-yhat_beta+fi;
		if det(x`*(w#Ai#x#wt))=0 then b=j(nvar,1,0);
		else b=inv(x`*(w#Ai#x#wt))*x`*(w#Ai#zj#wt); 
		nj=x*b+yhat_beta-fi;
		nj=choose(nj>1E2,1E2,nj);
		uj=exp(nj)/(1+exp(nj));
		olddev=dev;
		uj=choose(uj<1E-150,1E-150,uj);
		tt=y/uj;
		tt=choose(tt=0,1E-10,tt);
		uj=choose(uj=1,0.99999,uj);
		tt2=(1-y)/(1-uj);
		tt2=choose(tt2=0,1E-10,tt2);
		dev=2#sum((y#log(tt))+(1-y)#log(tt2));
		if cont>100 then ddev= 0.0000001;
		else ddev=dev-olddev;
	end;
	if nvar=nvarg then do;
		if det(x`*(w#Ai#x#wt))=0 then do;Sm[i,]=j(1,n,0);mRj[i,]=j(1,n*nvar,0);end;
		else do;
			ej=I(nvar);
			Sm[i,]= (x[i,]*inv(x`*(w#Ai#x#wt))*(x#w#wt#Ai)`);
			Sm3[i,]= vecdiag((inv(x`*(w#Ai#x#wt))*(x#w#wt#Ai)`)*diag(1/Ai)*(inv(x`*(w#Ai#x#wt))*(x#w#wt#Ai)`)`)`;
			do jj=1 to nvar;
			m1=(jj-1)*n+1;
			m2=m1+(n-1);
			mRj[i,m1:m2]= (x[i,jj]*ej[jj,]*inv(x`*(w#Ai#x#wt))*(x#w#wt#Ai)`);
			end;
		end;
	end;
	else do;
		if det(x`*(w#Ai#x#wt))=0 then Rj[i,]=j(1,n,0);
		else Rj[i,]= (x[i,]*inv(x`*(w#Ai#x#wt))*(x#w#wt#Ai)`);
	end;
%END;
	m1=(i-1)*nvar+1;
	m2=m1+(nvar-1);
	bim[m1:m2]=b;
	yhatm[i]=uj[i];
	yhat[i]=uj[i];
end;
_beta_=shape(bim,n);
yhbeta=yhatm||_beta_;
return(yhbeta);
finish;

/** Initial Values **/
%IF %UPCASE(&MGWR) ne YES %THEN %DO;
finb=j(n,1,0);
yhat_beta=offset;
%IF &H NE %THEN %DO;
h=&H;
%END;
%ELSE %DO;
h=GSS(y,x,finb);
%END;
print "General Bandwidth" h;
yhat_beta=gwr(h,y,x,finb);
_beta_=yhat_beta[,2:nvarg+1];
fi=x#_beta_;
mband=h;
Sm2=Sm;
%END;

%ELSE %DO;
finb=j(n,1,0);
yhat_beta=offset;
%IF &H NE %THEN %DO;
h=&H;
%END;
%ELSE %DO;
h=GSS(y,x,finb);
%END;
print "General Bandwidth" h;

/***** computing residuals ******/
yhat_beta=gwr(h,y,x,finb);
error=y-yhat_beta[,1];
_beta_=yhat_beta[,2:nvarg+1];
*print (_beta_[:,]) (alphai[:,2]);
*print error _beta_;
fi=x#_beta_;
/*fis=fi[,+];
%IF %UPCASE(&MODEL)=POISSON or %UPCASE(&MODEL)=NEGBIN %THEN %DO;
fis=exp(fis+offset);
%END;
print fis (yhat_beta[,1]);*/
Sm2=Sm;
do jj=1 to nvarg;
m1=(jj-1)*n+1;
m2=m1+(n-1);
*print (trace(mRj[,m1:m2]));
end;
*print (trace(Sm));
mband=j(1,nvarg,h);
socf=1;
int=1;
mband_socf=mband||socf;
varname1={'Intercept'}||varname||{'socf'};
create &output from mband_socf[colname=varname1];
do while (socf>0.001 & int<&INT);
fi_old=fi;
diffi=0;
fi2=0;
do i=1 to nvarg;
%IF %UPCASE(&MODEL)=GAUSSIAN %THEN %DO;
ferror=error+fi[,i];
%IF &H NE %THEN %DO;
mband[i]=&H;
%END;
%ELSE %DO;
mband[i]=GSS(ferror,x[,i],finb);
%END;
yhat_beta=gwr(mband[i],ferror,x[,i],finb);
_beta_[,i]=yhat_beta[,2];
fi[,i]=x[,i]#_beta_[,i];
error=y-fi[,+];
m1=(i-1)*n+1;
m2=m1+(n-1);
mRj2=mRj[,m1:m2];
mRj[,m1:m2]=Rj*mRj[,m1:m2]+Rj-Rj*Sm;
Sm=Sm-mRj2+mRj[,m1:m2];
Cm[,m1:m2]=(1/x[,i])#mRj[,m1:m2];
%END;
%IF %UPCASE(&MODEL)=POISSON or %UPCASE(&MODEL)=NEGBIN or 
%UPCASE(&MODEL)=LOGISTIC %THEN %DO;
yhat_beta=(fi[,+]+offset);
%IF &H NE %THEN %DO;
mband[i]=&H;
%END;
%ELSE %DO;
mband[i]=GSS(y,x[,i],fi[,i]);
%END;
yhat_beta=gwr(mband[i],y,x[,i],fi[,i]);
_beta_[,i]=yhat_beta[,2];
*print (yhat_beta[:])(_beta_[:,]) (alphai[:,2]);
fi[,i]=x[,i]#_beta_[,i];
*error=y-exp(fi[,+]+offset);
m1=(i-1)*n+1;
m2=m1+(n-1);
mRj2=mRj[,m1:m2];
mRj[,m1:m2]=Rj*mRj[,m1:m2]+Rj-Rj*Sm;
Sm=Sm-mRj2+mRj[,m1:m2];
Cm[,m1:m2]=(1/x[,i])#mRj[,m1:m2];
mAi[,i]=Ai;
%END;
diffi=diffi+((fi[,i]-fi_old[,i])##2)[:];
fi2=fi2+fi[,i];
end;
socf=sqrt(diffi/(fi2##2)[+]);
varname2={'Intercept'}||varname;
print 'Bandwidth',, int mband[label=' ' colname=varname2] socf;
int=int+1;
mband_socf=mband||socf;
append from mband_socf;
end;
%END;

%IF %UPCASE(&MODEL)=GAUSSIAN %THEN %DO;
	_beta_std=_beta_;
	_beta_[,2:ncol(_beta_)]=_beta_[,2:ncol(_beta_)]*stdy/stdx;
	_beta_[,1]=stdy*_beta_[,1]-(_beta_[,2:ncol(_beta_)]#meanx)[,+]+meany;
%END;
%ELSE %DO;
	_beta_std=_beta_;
	_beta_[,2:ncol(_beta_)]=_beta_[,2:ncol(_beta_)]/stdx;
	_beta_[,1]=_beta_[,1]-(_beta_[,2:ncol(_beta_)]#meanx)[,+];
%END;

v1=trace(Sm);
%IF %UPCASE(&MODEL)=GAUSSIAN %THEN %DO;
yhat=fi[,+];
res=(y-yhat);
rsqr1=(res#wt)`*res;
ym=(y#wt)`*y;
rsqr2=ym-((y#wt)[+]**2)/wt[+];
rsqr=1-rsqr1/rsqr2;
rsqradj=1-((n-1)/(n-v1))*(1-rsqr);
sigma2=n*rsqr1/((n-v1)*wt[+]);
root_mse=sqrt(sigma2);
%END;

do jj=1 to nvarg;
m1=(jj-1)*n+1;
m2=m1+(n-1);
*print (trace(mRj[,m1:m2]));
ENP[jj]=trace(mRj[,m1:m2]);
%IF %UPCASE(&MGWR) ne YES %THEN %DO;
ENP[jj]=trace(Sm);
%END;

%IF %UPCASE(&MODEL)=GAUSSIAN %THEN %DO;
stdbm[,jj]=sqrt(vecdiag(sigma2*Cm[,m1:m2]*Cm[,m1:m2]`));
%IF %UPCASE(&MGWR) ne YES %THEN %DO;
stdbm[,jj]=sqrt(sigma2*Sm3[,jj]);
%END;
%END;
%IF %UPCASE(&MODEL)=POISSON or %UPCASE(&MODEL)=NEGBIN or 
%UPCASE(&MODEL)=LOGISTIC %THEN %DO;
%IF %UPCASE(&MGWR)=YES %THEN %DO;
stdbm[,jj]=sqrt(vecdiag(Cm[,m1:m2]*diag(1/mAi[,jj])*Cm[,m1:m2]`));
%END;
%ELSE %DO;
stdbm[,jj]=sqrt(Sm3[,jj]);
%END;
%END;
end;

%IF %UPCASE(&MODEL)=GAUSSIAN %THEN %DO;
stdbm[,1]=sqrt(stdbm[,1]##2+((stdy##2)*(stdbm[,2:ncol(stdbm)]##2/(stdx##2))#(meanx##2))[,+]);
stdbm[,2:ncol(stdbm)]=sqrt((stdy##2)*stdbm[,2:ncol(stdbm)]##2/(stdx##2));
%END;
%ELSE %DO;
stdbm[,1]=sqrt(stdbm[,1]##2+((stdbm[,2:ncol(stdbm)]##2/(stdx##2))#(meanx##2))[,+]);
stdbm[,2:ncol(stdbm)]=sqrt(stdbm[,2:ncol(stdbm)]##2/(stdx##2));
%END;

%IF %UPCASE(&MODEL)=GAUSSIAN %THEN %DO;
ll=-n*log(rsqr1/n)/2-n*log(2*arcos(-1))/2-sum((y-yhat)#(y-yhat))/(2*(rsqr1/n));
AIC=2*v1-2*ll;
AICc=AIC+2*(v1*(v1+1)/(n-v1-1));
print sigma2[label='Sigma2e'] root_mse[label='Root MSE'];
print rsqr[format=comma6.4 label="R-Square"] rsqradj[format=comma6.4 label="Adj-R-Square"];
print ll[label='Full Log Likelihood'] AIC AICc;
%END;
%IF %UPCASE(&MODEL)=POISSON %THEN %DO;
yhat=exp(fi[,+]+offset);
tt=y/yhat;
tt=choose(tt=0,1E-10,tt);
dev=2*sum(y#log(tt)-(y-yhat));
ll=sum(-yhat+y#log(yhat)-lgamma(y+1));
AIC=2*v1-2*ll;
AICc=AIC+2*(v1*(v1+1)/(n-v1-1));
tt2=y/y[:];tt2=choose(tt2=0,1E-10,tt2);
devnull=2*sum(y#log(tt2)-(y-y[:]));
pctdev=1-dev/devnull;
adjpctdev=1-((n-1)/(n-v1))*(1-pctdev);
print dev[label='Deviance'] ll[label='Full Log Likelihood'] pctdev adjpctdev AIC AICc;
%END;
%IF %UPCASE(&MODEL)=NEGBIN %THEN %DO;
yhat=exp(fi[,+]+offset);
tt=y/yhat;
tt=choose(tt=0,1E-10,tt);
dev=2*sum(y#log(tt)-(y+1/alphai[,2])#log((1+alphai[,2]#y)/(1+alphai[,2]#yhat)));
ll=sum(y#log(alphai[,2]#yhat)-(y+1/alphai[,2])#log(1+alphai[,2]#yhat)+lgamma(y+1/alphai[,2])-lgamma(1/alphai[,2])-lgamma(y+1));
AIC=2*(v1+v1/nvarg)-2*ll;
AICc=AIC+2*(v1+v1/nvarg)*(v1+v1/nvarg+1)/(n-(v1+v1/nvarg)-1);
tt2=y/y[:];tt2=choose(tt2=0,1E-10,tt2);
devnull=2*sum(y#log(tt2)-(y+1/alphai[,2])#log((1+alphai[,2]#y)/(1+alphai[,2]#y[:])));
pctdev=1-dev/devnull;
adjpctdev=1-((n-1)/(n-(v1+v1/nvarg)))*(1-pctdev);
print dev[label='Deviance'] ll[label='Full Log Likelihood'] pctdev adjpctdev AIC AICc;
%END;
%IF %UPCASE(&MODEL)=LOGISTIC %THEN %DO;
yhat=exp(fi[,+])/(1+exp(fi[,+]));
tt=y/yhat;
tt=choose(tt=0,1E-10,tt);
yhat2=choose(yhat=1,0.99999,yhat);
tt2=(1-y)/(1-yhat2);
tt2=choose(tt2=0,1E-10,tt2);
dev=2#sum((y#log(tt))+(1-y)#log(tt2));
lyhat2=1-yhat;
lyhat2=choose(lyhat2=0,1E-10,lyhat2);
ll=sum(y#log(yhat)+(1-y)#log(lyhat2));
AIC=2*v1-2*ll;
AICc=AIC+2*(v1*(v1+1)/(n-v1-1));
tt=y/y[:];
tt=choose(tt=0,1E-10,tt);
tt2=(1-y)/(1-y[:]);
tt2=choose(tt2=0,1E-10,tt2);
devnull=2#sum((y#log(tt))+(1-y)#log(tt2));
pctdev=1-dev/devnull;
adjpctdev=1-((n-1)/(n-v1))*(1-pctdev);
print dev[label='Deviance'] ll[label='Full Log Likelihood'] pctdev adjpctdev AIC AICc;
%END;

ENP[nvarg+1]=trace(Sm);
ENP[nvarg+2]=trace(Sm2);
varname_enp={'Intercept'}||varname||{'MGWR'}||{'GWR'};
%IF %UPCASE(&MODEL)=NEGBIN %THEN %DO;
ENP=ENP||(v1/nvarg);
varname_enp=varname_enp||{'alpha'};
%END;
print ENP[colname=varname_enp];
df=n-v1;
_tstat_=_beta_/stdbm;
_probt_=2*(1-probt(abs(_tstat_),df));
_malpha_=ENP;
_malpha_[1:nvarg]=0.05/ENP[1:nvarg];
_malpha_[nvarg+1]=0.05*(nvarg/v1);
_malpha_[nvarg+2]=0.05*(nvarg/trace(Sm2));
%IF %UPCASE(&MGWR) ne YES %THEN %DO;
_malpha_[1:nvarg]=0.05*(nvarg/v1);
%END;
%IF %UPCASE(&MODEL)=NEGBIN %THEN %DO;
_malpha_[nvarg+3]=0.05*(nvarg/v1);
%END;
_t_critical_=abs(tinv(_malpha_/2,df));

_beta2_=_beta_;
%IF %UPCASE(&MODEL)=NEGBIN %THEN %DO;
_alpha_=alphai[,2];
_beta2_=_beta_||_alpha_;
%END;
call qntl(qntl,_beta2_);
qntl=qntl//(qntl[3,]-qntl[1,]);
descriptb=_beta2_[:,]//_beta2_[><,]//_beta2_[<>,];

print qntl[label="Quantiles of MGWR Parameter Estimates" 
rowname={"P25", "P50", "P75", "IQR"} colname={'Intercept' &xvar %IF %UPCASE(&MODEL)=NEGBIN %THEN %DO;'alpha' %END;}],,
descriptb[label="Descriptive Statistics" rowname={"Mean", "Min", "Max"} 
colname={'Intercept' &xvar %IF %UPCASE(&MODEL)=NEGBIN %THEN %DO;'alpha' %END;}];

_stdbeta_=stdbm;
_stdbeta2_=_stdbeta_;
%IF %UPCASE(&MODEL)=NEGBIN %THEN %DO;
_stdalpha_=alphai[,3];
_stdbeta2_=_stdbeta_||_stdalpha_;
%END;
call qntl(qntls,_stdbeta2_);
qntls=qntls//(qntls[3,]-qntls[1,]);
descripts=_stdbeta2_[:,]//_stdbeta2_[><,]//_stdbeta2_[<>,];

print _malpha_[label="alpha-level=0.05" colname=varname_enp];
print _t_critical_[format=comma6.2 label="t-Critical" colname=varname_enp];
print qntls[label="Quantiles of MGWR Standard Errors" 
rowname={"P25", "P50", "P75", "IQR"} colname={'Intercept' &xvar %IF %UPCASE(&MODEL)=NEGBIN %THEN %DO;'alpha' %END;}],,
descripts[label="Descriptive Statistics of Standard Errors" rowname={"Mean", "Min", "Max"} 
colname={'Intercept' &xvar %IF %UPCASE(&MODEL)=NEGBIN %THEN %DO;'alpha' %END;}];

/***** global estimates ***************/
%IF %UPCASE(&MODEL)=GAUSSIAN %THEN %DO;
bg=inv(x`*(x#wt))*x`*(y#wt);
s2g=((y-x*bg)#wt)`*(y-x*bg)/(n-nrow(bg));
varg=vecdiag(inv(x`*(x#wt))*s2g);
vargd=varg;
stdg=sqrt(vargd);
tg=bg/stdg;
b2=bg;
bg[2:nrow(bg)]=bg[2:nrow(bg)]*stdy/stdx`;
bg[1]=stdy*bg[1]-(bg[2:nrow(bg)]#meanx`)[+]+meany;
stdg=bg/tg;
stdg[1]=sqrt(varg[1]+((stdy##2)#(varg[2:nrow(varg)]/(stdx##2)`)#(meanx##2)`)[+]);
tg=bg/stdg;
dfg=n-nrow(bg);
probtg=2*(1-probt(abs(tg),dfg));
%END;

%IF &WEIGHT = %THEN %DO;
vargd=varg;
dfg=n-nrow(bg);
%END;

%IF %UPCASE(&MODEL)=NEGBIN %THEN %DO;
stdg=sqrt(varg);
b2=bg;
bg=bg//alphag;
stdg=stdg//sealphag;
stdg[1]=sqrt(stdg[1]##2+((stdg[2:nrow(stdg)-1]##2/(stdx##2)`)#(meanx##2)`)[+]);
stdg[2:nrow(stdg)-1]=sqrt(stdg[2:nrow(stdg)-1]##2/(stdx##2)`);
bg[2:nrow(bg)-1]=bg[2:nrow(bg)-1]/stdx`;
bg[1]=bg[1]-(bg[2:nrow(bg)-1]#meanx`)[+];
dfg=dfg-1;
tg=bg/stdg;
probtg=2*(1-probt(abs(tg),dfg));
%END;
%IF %UPCASE(&MODEL)=POISSON %THEN %DO;
stdg=sqrt(varg);
b2=bg;
stdg[1]=sqrt(stdg[1]##2+((stdg[2:nrow(stdg)]##2/(stdx##2)`)#(meanx##2)`)[+]);
stdg[2:nrow(stdg)]=sqrt(stdg[2:nrow(stdg)]##2/(stdx##2)`);
bg[2:nrow(bg)]=bg[2:nrow(bg)]/stdx`;
bg[1]=bg[1]-(bg[2:nrow(bg)]#meanx`)[+];
tg=bg/stdg;
probtg=2*(1-probt(abs(tg),dfg));
%END;
bg_stdg=bg||stdg;
print "Global Parameter Estimates",,bg_stdg[label=' ' rowname={'Intercept' &xvar %IF %UPCASE(&MODEL)=NEGBIN %THEN %DO;'alpha' %END;}
colname={"Par. Est." "Std Error"}] tg[format=comma6.2 label="t Value"] probtg[format=pvalue6. label="Pr > |t|"],,
"NOTE: The denominator degrees of freedom for the t tests is" dfg[label=' ']".";

%IF %UPCASE(&MODEL)=GAUSSIAN %THEN %DO;
x=xnstd;
x=j(n,1,1)||x;
y=ynstd;
resg=(y-x*bg);
rsqr1g=(resg#wt)`*resg;
ymg=(y#wt)`*y;
rsqr2g=ymg-((y#wt)[+]**2)/wt[+];
rsqrg=1-rsqr1g/rsqr2g;
rsqradjg=1-((n-1)/(n-nrow(bg)))*(1-rsqrg);
sigma2g=n*rsqr1g/((n-nrow(bg))*wt[+]);
root_mseg=sqrt(sigma2g);
print sigma2g[label='Sigma2e'] root_mseg[label='Root MSE'];
print rsqrg[format=comma6.4 label="R-Square"] rsqradjg[format=comma6.4 label="Adj-R-Square"];
ll=-n*log(rsqr1g/n)/2-n*log(2*arcos(-1))/2-sum(resg#resg)/(2*(rsqr1g/n));
AIC=-2*ll+2*nrow(bg);
AICc=-2*ll+2*nrow(bg)*(n/(n-nrow(bg)-1));
print ll[label='Full Log Likelihood'] AIC AICc;
%END;
%IF %UPCASE(&MODEL)=POISSON %THEN %DO;
yhatg=exp(x*bg+offset);
ll=sum(-yhatg+y#log(yhatg)-lgamma(y+1));
AIC=-2*ll+2*nvarg;
AICc=-2*ll+2*nvarg*(n/(n-nvarg-1));
tt2=y/y[:];tt2=choose(tt2=0,1E-10,tt2);
devnullg=2*sum(y#log(tt2)-(y-y[:]));
pctdevg=1-devg/devnullg;
adjpctdevg=1-((n-1)/(n-nvarg))*(1-pctdevg);
print devg[label='Deviance'] ll[label='Full Log Likelihood'] pctdevg adjpctdevg AIC AICc;
%END;
%IF %UPCASE(&MODEL)=NEGBIN %THEN %DO;
yhatg=exp(x*bg[1:nrow(bg)-1]+offset);
ll=sum(y#log(alphag#yhatg)-(y+1/alphag)#log(1+alphag#yhatg)+lgamma(y+1/alphag)-lgamma(1/alphag)-lgamma(y+1));
AIC=-2*ll+2*(nvarg+1);
AICc=-2*ll+2*(nvarg+1)*(n/(n-(nvarg+1)-1));
tt2=y/y[:];tt2=choose(tt2=0,1E-10,tt2);
devnullg=2*sum(y#log(tt2)-(y+1/alphag)#log((1+alphag#y)/(1+alphag#y[:])));
pctdevg=1-devg/devnullg;
adjpctdevg=1-((n-1)/(n-nvarg))*(1-pctdevg);
print devg[label='Deviance'] ll[label='Full Log Likelihood'] pctdevg adjpctdevg AIC AICc;
%END;
%IF %UPCASE(&MODEL)=LOGISTIC %THEN %DO;
x=xnstd;
x=j(n,1,1)||x;
yhatg=exp(x*bg)/(1+exp(x*bg));
lyhat2=1-yhatg;
lyhat2=choose(lyhat2=0,1E-10,lyhat2);
ll=sum(y#log(yhatg)+(1-y)#log(lyhat2));
AIC=-2*ll+2*nvarg;
AICc=-2*ll+2*nvarg*(n/(n-nvarg-1));
tt=y/y[:];
tt=choose(tt=0,1E-10,tt);
tt2=(1-y)/(1-y[:]);
tt2=choose(tt2=0,1E-10,tt2);
devnullg=2#sum((y#log(tt))+(1-y)#log(tt2));
pctdevg=1-devg/devnullg;
adjpctdevg=1-((n-1)/(n-nvarg))*(1-pctdevg);
print devg[label='Deviance'] ll[label='Full Log Likelihood'] pctdevg adjpctdevg AIC AICc;
%END;
/****************************************/

_bistdt_=COORD||_beta_||stdbm||_tstat_||_probt_;
_colname1_={"Intercept" &xvar};
_label_=repeat("std_",nvarg)//repeat("tstat_",nvarg)//repeat("probt_",nvarg);
_colname_={"x" "y"}||_colname1_||concat(_label_,repeat(_colname1_`,3))`;
call change(_colname_, "_ ", "_");
call change(_colname_, "_ ", "_");
create _parameters2_ from _bistdt_[colname=_colname_];
append from _bistdt_;
close _parameters2_;

_sig_=j(n,nvarg,"not significant at 90%");
do i=1 to n;
do j=1 to nvarg;
if _probt_[i,j]<0.01/ENP[j] then _sig_[i,j]="significant at 99%";
else if _probt_[i,j]<0.05/ENP[j] then _sig_[i,j]="significant at 95%";
else if _probt_[i,j]<0.1/ENP[j] then _sig_[i,j]="significant at 90%";
else _sig_[i,j]="not significant at 90%";
end;
end;
_label_=repeat("sig_",nvarg);
_colname_=concat(_label_,repeat(_colname1_`,1))`;
create _sig_parameters2_ from _sig_[colname=_colname_];
append from _sig_;
close _sig_parameters2_;

%IF %UPCASE(&MODEL)=NEGBIN %THEN %DO;
atstat= alphai[,2]/alphai[,3];
aprobtstat=2*(1-probnorm(abs(atstat)));
_siga_=j(n,1,"not significant at 90%");
do i=1 to n;
if aprobtstat[i]<0.01*(nvarg/v1) then _siga_[i]="significant at 99%";
else if aprobtstat[i]<0.05*(nvarg/v1) then _siga_[i]="significant at 95%";
else if aprobtstat[i]<0.1*(nvarg/v1) then _siga_[i]="significant at 90%";
else _siga_[i]="not significant at 90%";
end;
alphai=alphai||atstat||aprobtstat;
create _alpha_ from alphai[colname={"id" "alpha" "std" "tstat" "probt"}];
append from  alphai;
create _sig_alpha_ from _siga_[colname={"sig_alpha"}];
append from _siga_;
%END;

/**********************************/
varname={'Intercept'}||varname;
create _min_bandwidth_ from mband[colname=varname];
append from mband;
quit;
data _parameters2_;merge _parameters2_ _sig_parameters2_;run;
%IF %UPCASE(&MODEL)=NEGBIN %THEN %DO;
data _alpha_;merge _alpha_ _sig_alpha_;run;
%END;
%mend MGWR;
